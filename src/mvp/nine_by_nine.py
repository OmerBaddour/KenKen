"""
Reasonably generic template for solving 9x9 KenKen puzzles, generated by src/mvp/n_by_n_metaprogrammer.py with input 9

Specifically, this is a solver for https://www.kenkenpuzzle.com/game, PUZZLE NO. 74592, 9X9, HARD

Important note: the runtime for puzzles of this size and complexity is approximately 15 minutes

To adapt this program for solving other 9x9 puzzles, replace all constraints with those for the specific problem instance.
- Constraints with addition are of the form [z3.And(X[a][b] + X[c][d] == y)]
- Constraints with subtraction are of the form [z3.And(z3_abs(X[a][b] - X[c][d]) == y)]
- Constraints with multiplication are of the form [z3.And(X[a][b] * X[c][d] == y)]
- Constraints with division are of the form [divide_constraint(X[a][b], X[c][d], y)]
"""
import z3


def z3_abs(x):
    """
    Absolute value of a z3 number

    Source: https://stackoverflow.com/questions/22547988/how-to-calculate-absolute-value-in-z3-or-z3py
    """
    return z3.If(x >= 0, x, -x)


def divide_constraint(X_i, X_j, ratio):
    """
    Ratio between two z3 numbers is constrained
    """
    return z3.Or(X_i / X_j == ratio, X_j / X_i == ratio)


if __name__ == "__main__":

    # 9x9 matrix of integer variables
    X = [[z3.Int("x_%s_%s" % (i + 1, j + 1)) for j in range(9)] for i in range(9)]

    # each cell contains a value in {1, ..., 9}
    cells_c = [z3.And(1 <= X[i][j], X[i][j] <= 9) for i in range(9) for j in range(9)]

    # each row contains a digit at most once
    rows_c = [z3.Distinct(X[i]) for i in range(9)]

    # each column contains a digit at most once
    cols_c = [z3.Distinct([X[i][j] for i in range(9)]) for j in range(9)]

    # constraints going left to right, top to bottom
    constraints = []
    # 1st row
    constraints.append([z3.And(X[0][0] * X[1][0] == 30)])
    constraints.append([z3.And(X[0][1] * X[0][2] == 28)])
    constraints.append([z3.And(z3_abs(X[0][3] - X[0][4]) == 8)])
    constraints.append([z3.And(z3_abs(X[0][5] - X[0][6]) == 5)])
    constraints.append([z3.And(z3_abs(X[0][7] - X[0][8]) == 3)])
    # 2nd row
    constraints.append([z3.And(z3_abs(X[1][1] - X[1][2]) == 1)])
    constraints.append([z3.And(X[1][3] + X[1][4] + X[1][5] + X[1][6] == 10)])
    constraints.append([z3.And(X[1][7] + X[1][8] == 13)])
    # 3rd row
    constraints.append([z3.And(X[2][0] * X[2][1] * X[3][0] * X[3][1] == 1080)])
    constraints.append([z3.And(X[2][2] == 7)])
    constraints.append([z3.And(X[2][3] * X[2][4] * X[2][5] == 90)])
    constraints.append([z3.And(X[2][6] + X[3][6] + X[3][7] + X[4][6] == 14)])
    constraints.append([z3.And(X[2][7] * X[2][8] * X[3][8] == 6)])
    # 4th row
    constraints.append([divide_constraint(X[3][2], X[3][3], 2)])
    constraints.append([divide_constraint(X[3][4], X[3][5], 2)])
    # 5th row
    constraints.append([z3.And(X[4][0] == 7)])
    constraints.append([divide_constraint(X[4][1], X[4][2], 2)])
    constraints.append([z3.And(X[4][3] * X[4][4] * X[4][5] == 162)])
    constraints.append([z3.And(X[4][7] * X[5][6] * X[5][7] == 280)])
    constraints.append([z3.And(z3_abs(X[4][8] - X[5][8]) == 2)])
    # 6th row
    constraints.append([z3.And(X[5][0] * X[5][1] * X[5][2] * X[6][0] == 324)])
    constraints.append([divide_constraint(X[5][3], X[5][4], 2)])
    constraints.append([z3.And(z3_abs(X[5][5] - X[6][5]) == 4)])
    # 7th row
    constraints.append([divide_constraint(X[6][1], X[6][2], 2)])
    constraints.append([z3.And(X[6][3] + X[6][4] == 13)])
    constraints.append([z3.And(X[6][6] * X[7][6] == 18)])
    constraints.append([divide_constraint(X[6][7], X[6][8], 2)])
    # 8th row
    constraints.append([z3.And(X[7][0] + X[8][0] == 5)])
    constraints.append([z3.And(X[7][1] + X[7][2] + X[7][3] == 14)])
    constraints.append([z3.And(z3_abs(X[7][4] - X[7][5]) == 1)])
    constraints.append([z3.And(z3_abs(X[7][7] - X[7][8]) == 5)])
    # 9th row
    constraints.append([z3.And(X[8][1] * X[8][2] * X[8][3] == 35)])
    constraints.append([z3.And(X[8][4] + X[8][5] + X[8][6] == 16)])
    constraints.append([divide_constraint(X[8][7], X[8][8], 3)])

    kenken_c = cells_c + rows_c + cols_c
    for constraint in constraints:
        kenken_c += constraint

    # initialize with all empty cells
    instance = ((0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0, 0))
    instance_c = [
        z3.If(instance[i][j] == 0, True, X[i][j] == instance[i][j])
        for i in range(9)
        for j in range(9)
    ]

    s = z3.Solver()
    s.add(kenken_c + instance_c)
    if s.check() == z3.sat:
        m = s.model()
        r = [[m.evaluate(X[i][j]) for j in range(9)] for i in range(9)]
        z3.print_matrix(r)
    else:
        print("failed to solve")